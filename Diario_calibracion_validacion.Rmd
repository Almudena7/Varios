---
title: "Diario_calibracion_validacion"
output: html_document
---

```{r}
# Definir directorio: si se abre desde "Project" es necesario abrirlo desde el menú (Session>Set working directory>...)
setwd("C:/DELL/GDrive_2/Instar/calibracion_validacion/fuentes_datos_validacion/COPLAS_PLAGAS/")
```

## Datos INSTAR crudos:
   
```{r}
# Datos crudos de INSTAR_SN:
huevos <-read.table("huevos_sn.csv", header=T, sep=",", dec=".")
L1 <-read.table("L1_sn.csv", header=T, sep=",", dec=".")
L2 <-read.table("L2_sn.csv", header=T, sep=",", dec=".")
crisalidas <-read.table("crisalidas_sn.csv", header=T, sep=",", dec=".")
exergia <-read.table("vigor_sn.csv", header=T, sep=",", dec=".")

# Juntamos todos en una misma tabla

INSTAR_SN <- cbind(huevos, L1$L1, L2$L2, crisalidas$crisalida, exergia$exergia)
names(INSTAR_SN)[1] <- "fecha"
names(INSTAR_SN)[3] <- "l1"
names(INSTAR_SN)[4] <- "l2"
names(INSTAR_SN)[5] <- "crisalidas"
names(INSTAR_SN)[6] <- "exergia"

# Crear columna anio
INSTAR_SN$fecha <-as.Date(INSTAR_SN$fecha, format="%d-%m-%y")
INSTAR_SN$anio<-as.numeric(format(INSTAR_SN$fecha, "%Y"))
```

**Importante**: recordar que mientras huevos, l1, l2 y crisalidas son valores absolutos (numero total de individuos en el mundo Netlogo), exergia es la media del vigor de todos los hospedadores del mundo NetLogo.

En nuestros datos hay solapamiento de fases no consecutivas (cosa que, en principio, no debería ocurrir).

# Agregacion de datos INSTAR: 

En cualquier caso, *la agregación no se debería hacer por año natural, sino por ciclo biológico!*

Entiendo que agregais los datos de NetLogo para poder hacer la regreson COPLAS vs INSTAR, es correcto? Sin embargo, sumar los datos de huevos, l1, l2 y crisalidas de todos los dias no parece adecuado, asi habra individuos que se cuentan dos veces no? Entiendo que es dificil encontrar el parametro adecuado, ya que no sabemos que huevos hoy son los mismos que maniana y cuales son nuevos... Antonio me comenta que ahi podria entrar un analisis de dinamica poblacional. Ya que la cosa se complica bastante, quizas para simplificar se podria probar con la media, el maximo y/o el minimo, que quizas sean valores mas reales que el acumulado que se ha usado hasta ahora. De hecho, "Resultados_agreg_Instar_SN.csv" tiene mas individuos en L2 que en L1, lo cual no tiene sentido...No?

## Agregacion por suma
La suma de los individuos de cada instar para un mismo anio es una forma de calcular los "dias equivalentes del instar". Asi, sumando todos los l1 de un anio no obtenemos numero total de l1 sino dias equivalentes de afeccion de l1. Por tanto, la suma tiene sentido para "huevos", "l1", "l2" y "crisalidas", no para "exergia":

```{r}
sum_huevos <- aggregate(x = INSTAR_SN$huevos, by=list(anio=INSTAR_SN$anio), FUN=sum, na.rm=TRUE)
names(sum_huevos)[2] <- "sum_huevos"
sum_l1<- aggregate(x = INSTAR_SN$l1, by=list(anio=INSTAR_SN$anio), FUN=sum, na.rm=TRUE)
names(sum_l1)[2] <- "sum_l1"
sum_l2<- aggregate(x = INSTAR_SN$l2, by=list(anio=INSTAR_SN$anio), FUN=sum, na.rm=TRUE)
names(sum_l2)[2] <- "sum_l2"
sum_crisalidas<- aggregate(x = INSTAR_SN$crisalidas, by=list(anio=INSTAR_SN$anio), FUN=sum, na.rm=TRUE)
names(sum_crisalidas)[2] <- "sum_crisalidas"

sum_INSTAR<- cbind(sum_huevos,sum_l1, sum_l2, sum_crisalidas)
sum_INSTAR <- sum_INSTAR[ -c(3,5,7) ]
```

## Agregacion por maximo
Dos anios con el mismo numero de individuos pueden tener maximos muy diferentes, segun la puesta, eclosion, etc coincida mas o menos en el tiempo (mismo efecto que la media). El valor maximo, por tanto, debe ser usado con precaución, aunque si puede ser una manera de estimar (solo estimar!) el numero total de individuos que se han dado en un anio para un instar.

```{r}
max_huevos <- aggregate(x = INSTAR_SN$huevos, by=list(anio=INSTAR_SN$anio), FUN=max, na.rm=TRUE)
names(max_huevos)[2] <- "max_huevos"
max_l1 <- aggregate(x = INSTAR_SN$l1, by=list(anio=INSTAR_SN$anio), FUN=max, na.rm=TRUE)
names(max_l1)[2] <- "max_l1"
max_l2 <- aggregate(x = INSTAR_SN$l2, by=list(anio=INSTAR_SN$anio), FUN=max, na.rm=TRUE)
names(max_l2)[2] <- "max_l2"
max_crisalidas <- aggregate(x = INSTAR_SN$crisalidas, by=list(anio=INSTAR_SN$anio), FUN=max, na.rm=TRUE)
names(max_crisalidas)[2] <- "max_crisalidas"
max_exergia <- aggregate(x = INSTAR_SN$exergia, by=list(anio=INSTAR_SN$anio), FUN=max, na.rm=TRUE)
names(max_exergia)[2] <- "max_exergia"

max_INSTAR <- cbind(max_huevos,max_l1, max_l2, max_crisalidas, max_exergia)
max_INSTAR <- max_INSTAR[ -c(3,5,7,9) ]
```

## Agregacion por minimo
La agregacion por minimo claramente subestima la poblacion, al menos en huevos, l1, l2 y crisalidas, ya que debido a la estacionalidad de cada fase se dan dias con valores 0, y por tanto el minimo es 0, no siendo este valor representativo de la poblacion ese anio. Si puede tener sentido para exergia, asi que la mantenemos:

```{r}
#min_huevos <- aggregate(x = INSTAR_SN$huevos, by=list(anio=INSTAR_SN$anio), FUN=min, na.rm=TRUE)
# names(min_huevos)[2] <- "min_huevos"
# min_l1 <- aggregate(x = INSTAR_SN$l1, by=list(anio=INSTAR_SN$anio), FUN=min, na.rm=TRUE)
# names(min_l1)[2] <- "min_l1"
# min_l2 <- aggregate(x = INSTAR_SN$l2, by=list(anio=INSTAR_SN$anio), FUN=min, na.rm=TRUE)
# names(min_l2)[2] <- "min_l2"
# min_crisalidas <- aggregate(x = INSTAR_SN$crisalidas, by=list(anio=INSTAR_SN$anio), FUN=min, na.rm=TRUE)
# names(min_crisalidas)[2] <- "min_crisalidas"
min_exergia <- aggregate(x = INSTAR_SN$exergia, by=list(anio=INSTAR_SN$anio), FUN=min, na.rm=TRUE)
names(min_exergia)[2] <- "min_exergia"

#min_INSTAR <- cbind(min_huevos,min_l1, min_l2, min_crisalidas, min_exergia)
min_INSTAR <- cbind(min_exergia)
#min_INSTAR <- min_INSTAR[ -c(3,5,7,9) ]
```

## Agregacion por media
La agregacion por media tiene el problema de que para dos anios con el mismo numero total de individuos, en un anio con el instar que sea (huevos, l1, l2 o crisalidas) muy repartidos a lo largo del tiempo, la media saldra menor que la de un anio con el mismo numero de individuos pero concentrados en un periodo mas corto de tiempo.

```{r}
mean_huevos <- aggregate(x = INSTAR_SN$huevos, by=list(anio=INSTAR_SN$anio), FUN=mean, na.rm=TRUE)
names(mean_huevos)[2] <- "mean_huevos"
mean_l1 <- aggregate(x = INSTAR_SN$l1, by=list(anio=INSTAR_SN$anio), FUN=mean, na.rm=TRUE)
names(mean_l1)[2] <- "mean_l1"
mean_l2 <- aggregate(x = INSTAR_SN$l2, by=list(anio=INSTAR_SN$anio), FUN=mean, na.rm=TRUE)
names(mean_l2)[2] <- "mean_l2"
mean_crisalidas <- aggregate(x = INSTAR_SN$crisalidas, by=list(anio=INSTAR_SN$anio), FUN=mean, na.rm=TRUE)
names(mean_crisalidas)[2] <- "mean_crisalidas"
mean_exergia <- aggregate(x = INSTAR_SN$exergia, by=list(anio=INSTAR_SN$anio), FUN=mean, na.rm=TRUE)
names(mean_exergia)[2] <- "mean_exergia"

mean_INSTAR <- cbind(mean_huevos, mean_l1, mean_l2, mean_crisalidas, mean_exergia)
mean_INSTAR <- mean_INSTAR[ -c(3,5,7,9) ]
```

## Exportacion de datos de agregacion
```{r}
# Creamos una tabla con todos los datos de agregacion y la exportamos

agreg_INSTAR_SN <- cbind(
  sum_huevos, max_huevos, mean_huevos, 
  sum_l1, max_l1, mean_l1,
  sum_l2, max_l2, mean_l2,
  sum_crisalidas, max_crisalidas,  mean_crisalidas,
  max_exergia, mean_exergia, min_exergia)
agreg_INSTAR_SN <- agreg_INSTAR_SN[ -c(3,5,7,9,11,13,15,17,19,21,23,25,27,29) ]

# write.csv(agreg_INSTAR_SN, "agreg_INSTAR_SN.csv", row.names=FALSE, na="")
```

## Importacion de datos de agregacion
```{r}
agreg_INSTAR_SN<-read.table("agreg_INSTAR_SN.csv", header=T, sep=",", dec=".")
```

# Regresion: 

Por lo que veo habeis calculado una regresion lineal entre COPLAS e INSTAR, por que esperais una relacion lineal entre ambas variables? Lo ideal seria buscar la funcion que explica dicha relacion, y ver que tipo de funcion (lineal, logaritmica...) es, no? En cualquier caso, quizas lo mas esperable es una funcion logaritmica, como hace Cayuela (hace un glm, pero sobre datos en base logaritmica!). Intuitivamente, yo esperaria que para percibir cierta defoliacion es necesario un numero minimo de individuos, por debajo del cual no se observa defoliacion y a partir de cierta cantidad de individuos la defoliacion es maxima, dando igual si ese valor se sobrepasa por mucho o por poco (si todos los arboles estan defoliados da igual que haya X que X*10 individuos, por lo que ya no hay relacion lineal), por lo que yo esperaria una relacion exponencial.

Me preocupa que hay muchos datos 0 de COPLAS con valores muuuy diferentes de NetLogo... La agregacion juega un papel importante ahi, quizas al usar otra agregacion sale algo mejor (esperemos).

## Transformacion log de datos INSTAR

~~**DUDA* Es e la base correcta?~~ Parece que si (e-mail Almu) :)

```{r}
log_agreg_INSTAR_SN<- data.frame(
  "anio" = agreg_INSTAR_SN$anio, 
  log_sum_huevos = (log(agreg_INSTAR_SN$sum_huevos)), 
  log_max_huevos = (log(agreg_INSTAR_SN$max_huevos)), 
  log_mean_huevos = (log(agreg_INSTAR_SN$mean_huevos)), 
  log_sum_l1 = (log(agreg_INSTAR_SN$sum_l1)), 
  log_max_l1 = (log(agreg_INSTAR_SN$max_l1)), 
  log_mean_l1 = (log(agreg_INSTAR_SN$mean_l1)),
  log_sum_l2 = (log(agreg_INSTAR_SN$sum_l2)), 
  log_max_l2 = (log(agreg_INSTAR_SN$max_l2)), 
  log_mean_l2 = (log(agreg_INSTAR_SN$mean_l2)),
  log_sum_crisalidas = (log(agreg_INSTAR_SN$sum_crisalidas)), 
  log_max_crisalidas = (log(agreg_INSTAR_SN$max_crisalidas)),  
  log_mean_crisalidas = (log(agreg_INSTAR_SN$mean_crisalidas)),
  log_max_exergia = (log(agreg_INSTAR_SN$max_exergia)), 
  log_mean_exergia = (log(agreg_INSTAR_SN$mean_exergia)), 
  log_min_exergia = (log(agreg_INSTAR_SN$min_exergia)))
```

## Importacion de datos de COPLAS y exploracion preliminar
```{r}
COPLAS_SN_completo<-read.csv("cortijuela.csv", header=TRUE, dec =".", sep=",") # Sin agregar, datos brutos

boxplot(COPLAS_SN_completo$GRADO.REVISADO ~ COPLAS_SN_completo$RODAL)
plot(COPLAS_SN_completo$GRADO.REVISADO ~ COPLAS_SN_completo$fecha)

COPLAS_SN<-read.csv("coplas_cortijuela_prueba.csv", header=TRUE, dec =".", sep=",") # Medias para cada rodal (agregado)
```

**DUDAS**
- Es correcto hacer la media (al menos tal y como esta hecha) en una variable discreta como es COPLAS? 
    -> Entiendo que si, pero habra que usar la media obtenida, no el redondeo
    -> Además lo adecuado sería ponderar según la superficie de cada rodal en el total (si tienen tamanios muy diferentes, al hacer la media se esta dando mas peso de la cuenta al pequenio y se esta subestimando el grande)
    
- En caso de que sea correcto, se debe/hay forma de considerar la varianza en la regresion?
- Debe considerarse COPLAS de alguna manera especial en la regresion por ser una variable discreta?

## Correlaciones y regresiones

**La variable independiente (x) son los datos de COPLAS, y la variable dependiente (y) son los datos de Instar:**

INSTAR = a·COPLAS + b (INSTAR "described by" COPLAS)

- Se cumplen las asunciones de una regresion? (normalidad,...) -> Usamos un glm, ya que lm asume que el error de los datos sigue una distribucion normal, mientras que el glm asume que otras distribuciones son posibles.
- lm o glm? (ver anterior) Hago el lm tambien para ver los R2
- cor y/o lm/glm?

```{r}
# Construccion de tabla
tabla_regresion <- cbind(log_agreg_INSTAR_SN, COPLAS_SN[-c((1:8), 23), -c(1,4)])

# Regresiones glm y resultados
reg1_glm  <- glm(tabla_regresion$log_sum_huevos ~ tabla_regresion$INFE_AVG)
reg2_glm  <- glm(tabla_regresion$log_max_huevos ~ tabla_regresion$INFE_AVG)
reg3_glm  <- glm(tabla_regresion$log_mean_huevos ~ tabla_regresion$INFE_AVG)
reg4_glm  <- glm(tabla_regresion$log_sum_l1 ~ tabla_regresion$INFE_AVG)
reg5_glm  <- glm(tabla_regresion$log_max_l1 ~ tabla_regresion$INFE_AVG)
reg6_glm  <- glm(tabla_regresion$log_mean_l1 ~ tabla_regresion$INFE_AVG)
reg7_glm  <- glm(tabla_regresion$log_sum_l2 ~ tabla_regresion$INFE_AVG)
reg8_glm  <- glm(tabla_regresion$log_max_l2 ~ tabla_regresion$INFE_AVG)
reg9_glm  <- glm(tabla_regresion$log_mean_l2 ~ tabla_regresion$INFE_AVG)
reg10_glm <- glm(tabla_regresion$log_sum_crisalidas ~ tabla_regresion$INFE_AVG)
reg11_glm <- glm(tabla_regresion$log_max_crisalidas ~ tabla_regresion$INFE_AVG)
reg12_glm <- glm(tabla_regresion$log_mean_crisalidas ~ tabla_regresion$INFE_AVG)
reg13_glm <- glm(tabla_regresion$log_max_exergia ~ tabla_regresion$INFE_AVG)
reg14_glm <- glm(tabla_regresion$log_mean_exergia ~ tabla_regresion$INFE_AVG)
reg15_glm <- glm(tabla_regresion$log_min_exergia ~ tabla_regresion$INFE_AVG)

summary(reg1_glm)
summary(reg2_glm)
summary(reg3_glm)
summary(reg4_glm)
summary(reg5_glm)
summary(reg6_glm)
summary(reg7_glm)
summary(reg8_glm)
summary(reg9_glm)
summary(reg10_glm)
summary(reg11_glm)
summary(reg12_glm)
summary(reg13_glm)
summary(reg14_glm)
summary(reg15_glm)

# Regresiones glm y resultados
reg1_lm  <- lm(tabla_regresion$log_sum_huevos ~ tabla_regresion$INFE_AVG)
reg2_lm  <- lm(tabla_regresion$log_max_huevos ~ tabla_regresion$INFE_AVG)
reg3_lm  <- lm(tabla_regresion$log_mean_huevos ~ tabla_regresion$INFE_AVG)
reg4_lm  <- lm(tabla_regresion$log_sum_l1 ~ tabla_regresion$INFE_AVG)
reg5_lm  <- lm(tabla_regresion$log_max_l1 ~ tabla_regresion$INFE_AVG)
reg6_lm  <- lm(tabla_regresion$log_mean_l1 ~ tabla_regresion$INFE_AVG)
reg7_lm  <- lm(tabla_regresion$log_sum_l2 ~ tabla_regresion$INFE_AVG)
reg8_lm  <- lm(tabla_regresion$log_max_l2 ~ tabla_regresion$INFE_AVG)
reg9_lm  <- lm(tabla_regresion$log_mean_l2 ~ tabla_regresion$INFE_AVG)
reg10_lm <- lm(tabla_regresion$log_sum_crisalidas ~ tabla_regresion$INFE_AVG)
reg11_lm <- lm(tabla_regresion$log_max_crisalidas ~ tabla_regresion$INFE_AVG)
reg12_lm <- lm(tabla_regresion$log_mean_crisalidas ~ tabla_regresion$INFE_AVG)
reg13_lm <- lm(tabla_regresion$log_max_exergia ~ tabla_regresion$INFE_AVG)
reg14_lm <- lm(tabla_regresion$log_mean_exergia ~ tabla_regresion$INFE_AVG)
reg15_lm <- lm(tabla_regresion$log_min_exergia ~ tabla_regresion$INFE_AVG)

summary(reg1_lm)
summary(reg2_lm)
summary(reg3_lm)
summary(reg4_lm)
summary(reg5_lm)
summary(reg6_lm)
summary(reg7_lm)
summary(reg8_lm)
summary(reg9_lm)
summary(reg10_lm)
summary(reg11_lm)
summary(reg12_lm)
summary(reg13_lm)
summary(reg14_lm)
summary(reg15_lm)

# Exploracion grafica.
plot(tabla_regresion$log_sum_huevos ~ tabla_regresion$INFE_AVG)
abline(lm(tabla_regresion$log_sum_huevos ~ tabla_regresion$INFE_AVG))
```

# Regresion multiple:

No entiendo esto... Si l2 viene de l1, al hacer una regresion multiple l1+l2 (o huevos+l1, o cualquier combinacion de variables de densidad de poblacion), no se esta metiendo una redundancia? Sin embargo, si me parece que podria ser interesante hacer una regresion multiple considerando una variable de densidad de poblacion y una relacionada con las condiciones climaticas (tmin, tmax y/o tmedia), ya que se podria esperar que, por ejemplo, huevos+tmin sea un buen predictor de COPLAS, no?

## Datos de temperatura:
```{r}
temp_sn<-read.csv("temp_sn.csv", header=TRUE, dec =".", sep=",")
```

# Series temporales  

No s? muy bien cu?l es el objetivo de el an?lisis de series temporales, por lo que quiz?s lo que digo no tiene sentido, corregidme plis :) 

*--> Cuantificar el grado de ajuste entre ambas series temporales (COPLAS e INSTAR)*

Seg?n lo entiendo, queremos hacer un an?lisis de series temporales comparando COPLAS e INSTAR, ya que al ser variables que cambian en el tiempo debido a varios factores (condiciones de cada a?o, estacionalidad, variabilidad,...) su an?lisis basado en regresi?n es limitado. En tal caso, creo que es una pena usar datos agregados de INSTAR (perdiendo resoluci?n) cuando precisamente el an?lisis como serie temporal nos mostrar?a la estacionalidad, la tendencia, etc. Por tanto, yo usar?a los datos brutos de INSTAR. Ahora, hay un problema, y es que la funci?n ts no se lleva bien con los a?os bisiestos, ya que la frecuencia tiene que ser un valor fijo para toda la serie (que no para dos series, por lo que no es un problema comparar COPLAS e INSTAR aunque tengan distinta frecuencia). En los foros proponen usar zoo para evitar este problema, que es lo que usamos en Ecoinform?tica, creo... Otra opci?n ser?a eliminar de los datos de INSTAR el 29 de febrero de los a?os bisiestos, aunque parece una soluci?n poco elegante...

En cuanto al error que te sale en el c?digo, entiendo que es porque cuando la frecuencia es 1, decompose no funciona ya que no se puede observar estacionalidad si hay una sola medida por a?o. Por eso cambiando a freq=2 se elimina el error, pero no es correcto ya que nosotros s?lo tenemos una medida/a?o. Por tanto, yo entiendo que no se puede aplicar la funci?n decompose sobre COPLAS, sino que habr? que buscar otras herramientas para evaluar tendencias. En cualquier caso, y despu?s de hablar con Antonio, yo entiendo que lo que habr?a que hacer es coger los datos de INSTAR, analizarlos (en bruto) como serie temporal, buscando estacionalidad, tendencias, ruido, etc. y quiz?s comparar esta serie con una serie clim?tica (tmin, tmax y/o tmedia), de esta manera demostrando que los resultados del modelo guardan relaci?n con las condiciones clim?ticas, como se espera del c?digo. Si adem?s encontramos la forma de analizar series temporales de frecuencia 1 entonces podr?amos comparar COPLAS e INSTAR.

```{r}
# Pruebas (basado en el reto final de ecoinform?tica)
## Exploratory plot
plot(INSTAR_SN$fecha, INSTAR_SN$huevos, type='o', 
      xlab='year', pch=19, col='#325B84',
      ylab='huevos', ylim=c(0,1500000))

## Trend analysis

library('Kendall') 
m <- MannKendall(INSTAR_SN$huevos)
m

# Creo que considera la serie como valores puntuales (no medidas diarias) por lo que no encuentra tendencia ya que sube y baja en cada a?o (tiene estacionalidad)

### Test a linear regression
ml <- lm(INSTAR_SN$fecha~INSTAR_SN$huevos)
summary(ml)

# ERROR: no sabe hacer un lm sobre una fecha

huevos_zoo <- zoo(INSTAR_SN$fecha~INSTAR_SN$huevos)

#Definimos la tabla como serie temporal - cada fila es una serie
str(huevos_zoo)
View(huevos_zoo)

huevos_theil <- mannKen(as.ts(huevos_zoo)) #Ejecutamos el test
View(nieve_theil)
nieve_theil<-as.data.frame(nieve_theil)
```
